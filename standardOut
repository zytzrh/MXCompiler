; ModuleID = 'code.txt'
source_filename = "code.txt"

@n = global i32 0
@p = global i32 0
@k = global i32 0
@i = global i32 0
@.str.0 = private unnamed_addr constant [4 x i8] c"<< \00"
@.str.1 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.2 = private unnamed_addr constant [3 x i8] c") \00"
@.str.3 = private unnamed_addr constant [2 x i8] c" \00"
@.str.4 = private unnamed_addr constant [4 x i8] c">> \00"

declare void @print(i8* %str.0)
declare void @println(i8* %str.0)
declare void @printInt(i32 %n.0)
declare void @printlnInt(i32 %n.0)
declare i8* @getString()
declare i32 @getInt()
declare i8* @toString(i32 %i.0)
declare i8* @malloc(i32 %size.0)
declare i8* @__string_concatenate(i8* %str1.0, i8* %str2.0)
declare i1 @__string_equal(i8* %str1.0, i8* %str2.0)
declare i1 @__string_notEqual(i8* %str1.0, i8* %str2.0)
declare i1 @__string_lessThan(i8* %str1.0, i8* %str2.0)
declare i1 @__string_greaterThan(i8* %str1.0, i8* %str2.0)
declare i1 @__string_lessEqual(i8* %str1.0, i8* %str2.0)
declare i1 @__string_greaterEqual(i8* %str1.0, i8* %str2.0)
declare i32 @__string_length(i8* %str.0)
declare i8* @__string_substring(i8* %str.0, i32 %left.0, i32 %right.0)
declare i32 @__string_parseInt(i8* %str.0)
declare i32 @__string_ord(i8* %str.0, i32 %pos.0)
declare i32 @__array_size(i8* %arr.0)

define void @__init__() {
entranceBlock.0:
    br label %returnBlock.0

returnBlock.0:                                    ; preds = %entranceBlock.0
    ret void
}

define i32 @main() {
entranceBlock.0:
    call void @__init__()
    %returnValue$addr.0 = alloca i32
    store i32 0, i32* %returnValue$addr.0
    %n.0 = load i32, i32* @n
    %call.0 = call i32 @getInt()
    store i32 %call.0, i32* @n
    %p.0 = load i32, i32* @p
    %call.1 = call i32 @getInt()
    store i32 %call.1, i32* @p
    %k.0 = load i32, i32* @k
    %call.2 = call i32 @getInt()
    store i32 %call.2, i32* @k
    %p.1 = load i32, i32* @p
    %k.1 = load i32, i32* @k
    %sub.0 = sub i32 %p.1, %k.1
    %greaterThan.0 = icmp sgt i32 %sub.0, 1
    br i1 %greaterThan.0, label %ifThenBlock.0, label %ifMergeBlock.0

ifThenBlock.0:                                    ; preds = %entranceBlock.0
    %stringLiteral.0 = getelementptr [4 x i8], [4 x i8]* @.str.0, i32 0, i32 0
    call void @print(i8* %stringLiteral.0)
    br label %ifMergeBlock.0

ifMergeBlock.0:                                   ; preds = %entranceBlock.0, %ifThenBlock.0
    %i.0 = load i32, i32* @i
    %p.2 = load i32, i32* @p
    %k.2 = load i32, i32* @k
    %sub.1 = sub i32 %p.2, %k.2
    store i32 %sub.1, i32* @i
    br label %forCondBlock.0

forCondBlock.0:                                   ; preds = %ifMergeBlock.0, %forStepBlock.0
    %i.1 = load i32, i32* @i
    %p.3 = load i32, i32* @p
    %k.3 = load i32, i32* @k
    %add.0 = add i32 %p.3, %k.3
    %lessEqual.0 = icmp sle i32 %i.1, %add.0
    br i1 %lessEqual.0, label %forBodyBlock.0, label %forMergeBlock.0


forStepBlock.0:                                   ; preds = %ifMergeBlock.2
    %i.7 = load i32, i32* @i
    %postInc.0 = add i32 %i.7, 1
    store i32 %postInc.0, i32* @i
    br label %forCondBlock.0

forBodyBlock.0:                                   ; preds = %forCondBlock.0
    %i.2 = load i32, i32* @i
    %lessEqual.1 = icmp sle i32 1, %i.2
    br i1 %lessEqual.1, label %logicalAndBranch.0, label %logicalAndMerge.0

forMergeBlock.0:                                  ; preds = %forCondBlock.0
    %p.5 = load i32, i32* @p
    %k.4 = load i32, i32* @k
    %add.1 = add i32 %p.5, %k.4
    %n.2 = load i32, i32* @n
    %lessThan.0 = icmp slt i32 %add.1, %n.2
    br i1 %lessThan.0, label %ifThenBlock.3, label %ifMergeBlock.3

ifThenBlock.2:                                    ; preds = %logicalAndMerge.0
    %i.4 = load i32, i32* @i
    %p.4 = load i32, i32* @p
    %equal.0 = icmp eq i32 %i.4, %p.4
    br i1 %equal.0, label %ifThenBlock.1, label %ifElseBlock.0

ifMergeBlock.2:                                   ; preds = %logicalAndMerge.0, %ifMergeBlock.1
    br label %forStepBlock.0

logicalAndBranch.0:                               ; preds = %forBodyBlock.0
    %i.3 = load i32, i32* @i
    %n.1 = load i32, i32* @n
    %lessEqual.2 = icmp sle i32 %i.3, %n.1
    br label %logicalAndMerge.0

logicalAndMerge.0:                                ; preds = %forBodyBlock.0, %logicalAndBranch.0
    %logicalAnd.0 = phi i1 [ false, %forBodyBlock.0 ], [ %lessEqual.2, %logicalAndBranch.0 ]
    br i1 %logicalAnd.0, label %ifThenBlock.2, label %ifMergeBlock.2

ifThenBlock.1:                                    ; preds = %ifThenBlock.2
    %stringLiteral.1 = getelementptr [2 x i8], [2 x i8]* @.str.1, i32 0, i32 0
    call void @print(i8* %stringLiteral.1)
    %i.5 = load i32, i32* @i
    %call.3 = call i8* @toString(i32 %i.5)
    call void @print(i8* %call.3)
    %stringLiteral.2 = getelementptr [3 x i8], [3 x i8]* @.str.2, i32 0, i32 0
    call void @print(i8* %stringLiteral.2)
    br label %ifMergeBlock.1

ifElseBlock.0:                                    ; preds = %ifThenBlock.2
    %i.6 = load i32, i32* @i
    call void @printInt(i32 %i.6)
    %stringLiteral.3 = getelementptr [2 x i8], [2 x i8]* @.str.3, i32 0, i32 0
    call void @print(i8* %stringLiteral.3)
    br label %ifMergeBlock.1

ifMergeBlock.1:                                   ; preds = %ifThenBlock.1, %ifElseBlock.0
    br label %ifMergeBlock.2

ifThenBlock.3:                                    ; preds = %forMergeBlock.0
    %stringLiteral.4 = getelementptr [4 x i8], [4 x i8]* @.str.4, i32 0, i32 0
    call void @print(i8* %stringLiteral.4)
    br label %ifMergeBlock.3

ifMergeBlock.3:                                   ; preds = %forMergeBlock.0, %ifThenBlock.3
    store i32 0, i32* %returnValue$addr.0
    br label %returnBlock.0

returnBlock.0:                                    ; preds = %ifMergeBlock.3
    %returnValue.0 = load i32, i32* %returnValue$addr.0
    ret i32 %returnValue.0
}

